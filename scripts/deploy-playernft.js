const { ethers } = require("hardhat");
const fs = require("node:fs");
const path = require("node:path");

async function main() {
	console.log("ğŸš€ Starting PlayerNFT deployment...");

	const PlayerNFT = await ethers.getContractFactory("PlayerNFT");
	const nft = await PlayerNFT.deploy();
	await nft.deployed();

	const address = nft.address;
	console.log(`âœ… PlayerNFT deployed to: ${address}`);

	const outputPath = path.join(
		__dirname,
		"../frontend/src/constants/addresses.ts",
	);

	let existing = {};
	if (fs.existsSync(outputPath)) {
		const raw = fs.readFileSync(outputPath, "utf8");

		// ğŸ‘‡ Match TypeScript export line
		const match = raw.match(/export const CONTRACTS = (\{[\s\S]*?\});/);
		if (match) {
			try {
				// Convert TypeScript object to JSON-safe format
				try {
					existing = JSON.parse(match[1]);
				} catch (e) {
					console.warn(
						"âš ï¸ Couldn't parse existing CONTRACTS as JSON, starting fresh.",
					);
				}
			} catch (e) {
				console.warn("âš ï¸ Couldn't parse existing CONTRACTS, starting fresh.");
			}
		}
	}

	// âœ… Update only playerNFTAddress
	existing.playerNFTAddress = address;

	// Regenerate TypeScript file
	const newContent = `// Auto-generated by deploy script
  export const CONTRACTS = ${JSON.stringify(existing, null, 2)};
  `;

	fs.writeFileSync(outputPath, newContent);
	console.log("ğŸ“ Updated: addresses.ts âœ…");
}

main().catch((error) => {
	console.error("âŒ Deployment failed:", error);
	process.exitCode = 1;
});
